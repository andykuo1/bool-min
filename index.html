<html>

<head>
  <title>The Project</title>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
  <style>
    table
    {
      border-collapse: separate;
      border-spacing: 5px 0;
    }
  </style>
  <script>
    function init()
    {
      $('#inputm').keyup(function(event){
        var src = $(this).val();
        var res = parse(src);
        if (res)
        {
          $('.output #mterms').text("[" + res.join(", ") + "]");
          outputInit();
        }
        else
        {
          $('.output #mterms').text("[" + "ERROR" + "]");
        }
      });

      $('#inputd').keyup(function(event){
        var src = $(this).val();
        var res = parse(src);
        if (res)
        {
          $('.output #dterms').text("[" + res.join(", ") + "]");
          outputInit();
        }
        else
        {
          $('.output #dterms').text("[" + "ERROR" + "]");
        }
      });
    }

    function parse(src)
    {
      var res = [];
      var terms = src.split(",");
      var term = "";

      for(var i = 0; i < terms.length; ++i)
      {
        term = terms[i].replace(/\s+/g, "");
        if (term.length == 0) continue;

        term = parseInt(term);
        if (isNaN(term))
        {
          return false;
        }
        else
        {
          res.push(term);
        }
      }

      return res;
    }
  </script>
  <script>
    var OneGroups = function()
    {
      this.groups = [];
      this.addGroup = function(onegroup) {
        for(var i = 0, len = onegroup.groups.length; i < len; ++i)
        {
          if (typeof onegroup.groups[i] == 'undefined') continue;
          if (typeof this.groups[i] == 'undefined')
          {
            this.groups[i] = [];
          }
          this.groups[i] = this.groups[i].concat(onegroup.groups[i]);
        }
      };
      this.getGroup = function(ones) {
        var g = this.groups[ones];
        if (typeof g == 'undefined')
        {
          g = [];
          g.name = "G" + ones;
        }
        return g;
      }
      this.addToGroup = function(ones, bitterm) {
        var g = this.groups[ones];
        if (!g) g = (this.groups[ones] = []);
        g.push(bitterm);
        return g;
      }
      this.size = function() {
        return this.groups.length;
      };
      this.isEmpty = function() {
        return this.groups.length == 0;
      };
      this.print = function() {
        console.log("= = BEGIN PRINT = =");
        for(var i = 0, len = this.groups.length; i < len; ++i)
        {
          console.log(" - G" + i);
          var g = this.getGroup(i);
          for(var j = 0, len2 = g.length; j < len2; ++j)
          {
            console.log(g[j]);
          }
        }
        console.log("= = END PRINT = =");
      };
    };
    var BitTerm = function(bits)
    {
      this.bits = bits;
      this.terms = [];
      this.dirty = false;

      this.getBits = function() {
        return this.bits;
      };
      this.addTerms = function(t) {
        if (t instanceof BitTerm)
        {
          this.terms.push(t);
        }
        else
        {
          this.terms = this.terms.concat(t);
        }
      };
      this.getTerms = function() {
        return this.terms.length == 0 ? this : this.terms;
      };
      this.hasTerms = function(t) {
        if (t instanceof BitTerm)
        {
          if (this.terms.length == 0)
          {
            return t.getBits() == this.getBits();
          }
          else
          {
            return containsBitTerm(this.terms, t);
          }
        }
        else
        {
          if (this.terms.length == 0)
          {
            for(var i = 0; i < t.length; ++i)
            {
              if (t.getBits() == this.getBits())
              {
                return true;
              }
            }
            return false;
          }
          else
          {
            for(var i = 0; i < t.length; ++i)
            {
              if (containsBitTerm(this.terms, t[i]) == true)
              {
                return true;
              }
            }
            return false;
          }
        }
      };
      this.removeTerms = function(t) {
        if (t instanceof BitTerm)
        {
          var i = this.terms.indexOf(t);
          if (i != -1)
          {
            this.terms.splice(i, 1);
          }
        }
        else
        {
          for(var i = 0; i < this.terms.length; ++i)
          {
            for(var j = 0; j < t.length; ++j)
            {
              if (this.terms[i] == t[j])
              {
                this.terms.splice(i, 1);
                --i;
              }
            }
          }
        }
      };
      this.isEmpty = function() {
        return this.terms.length == 0;
      };
      this.isDirty = function() {
        return this.dirty;
      };
      this.markDirty = function() {
        this.dirty = true;
        for(var i = 0; i < this.terms.length; ++i)
        {
          this.terms[i].markDirty();
        }
      };
      this.toCanonicalString = function() {
        var res = "";
        for(var i = 0, len = this.bits.length; i < len; ++i)
        {
          if (this.bits[i] == '-') continue;

          var s = String.fromCharCode('A'.charCodeAt(0) + i);
          if (this.bits[i] == '0')
          {
            res += s + "'";
          }
          else if (this.bits[i] == '1')
          {
            res += s + " ";
          }
          else
          {
            res += "??";
          }
        }
        return res;
      };
      this.toTermString = function() {
        if (this.terms.length > 0)
        {
          var s = "";
          for(var i = 0, len = this.terms.length; i < len; ++i)
          {
            if (i != 0) s += "-";
            s += this.terms[i].toTermString();
          }
          return s;
        }
        else
        {
          return parseInt(this.bits, 2);
        }
      };
      this.toString = function() {
        return this.bits;
      };
    };

    function formatBitTerm(ctx, term)
    {
      var str = term.toString(2);
      while(str.length < ctx.bits)
      {
        str = '0' + str;
      }
      return str;
    }

    function containsBitTerm(arr, bitterm)
    {
      for(var i = 0; i < arr.length; ++i)
      {
        if (arr[i].getBits() === bitterm.getBits())
        {
          return true;
        }
      }

      return false;
    }

    function diffBitTerms(ctx, a, b)
    {
      var diffs = numOfDiffs(ctx.bits, a, b);
      if (diffs == 1)
      {
        var d = 0;
        for(var i = 0, len = ctx.bits; i < len; ++i)
        {
          if (a[i] === b[i])
          {
            continue;
          }
          else
          {
            //The One Diff is Found
            return a.substr(0, i) + '-' + a.substr(i + 1);
          }
        }
      }
      else
      {
        return;
      }
    }

    function numOfDiffs(len, a, b)
    {
      var d = 0;
      for(var i = 0; i < len; ++i)
      {
        if (a[i] === b[i])
        {
          continue;
        }
        else
        {
          d++;
        }
      }
      return d;
    }

    function onesOfBitTerm(bitTerm)
    {
      var ones = 0;
      var i = bitTerm.length;
      while(i--)
      {
        if (bitTerm[i] == '1')
        {
          ones++;
        }
      }
      return ones;
    }

    function calcMostSigBitsOfTerms(terms)
    {
      var res = 0;
      for(var i = 0; i < terms.length; ++i)
      {
        var j = mostSigBits(terms[i]);
        if (j > res || res == 0)
        {
          res = j;
        }
      }
      return res;
    }

    function mostSigBits(num)
    {
      var sigbits = 0;
      while(num != 0)
      {
        sigbits++;
        num = num >> 1;
      }
      return sigbits;
    }

    function sortAndUnique(array)
    {
      if (array.length == 0) return array;
      array = array.sort(function(a, b) {return a * 1 - b * 1;});
      var res = [array[0]];
      for(var i = 1; i < array.length; ++i)
      {
        if (array[i-1] !== array[i])
        {
          res.push(array[i]);
        }
      }
      return res;
    }
  </script>
  <script>
  //draw truth table
  //draw circuit
  function createContext(mterms, dterms)
  {
    var umt = sortAndUnique(mterms);
    var udt = sortAndUnique(dterms);
    var t = umt.concat(udt);
    t = sortAndUnique(t);

    var ctx = {
      terms: [],
      mterms: [],
      dterms: [],
      bits: calcMostSigBitsOfTerms(t)
    };

    for(var i = 0, len = t.length; i < len; ++i)
    {
      var term = t[i];
      var bitterm = new BitTerm(formatBitTerm(ctx, term));
      if (umt.indexOf(term) != -1)
      {
        ctx.mterms.push(bitterm);
      }
      else
      {
        ctx.dterms.push(bitterm);
      }
      ctx.terms.push(bitterm);
    }

    return ctx;
  }

  function outputInit(ctx)
  {
    ctx = ctx || createContext(parse($('#inputm').val()), parse($('#inputd').val()));

    outputFunction(ctx);
    outputFunctionTable(ctx);
  }

  function outputFunction(ctx)
  {
    var result = "";
    //Output function
    result += "F(";
    for(var i = 0, len = ctx.bits; i < len; ++i)
    {
      if (i != 0) result += ", ";
      result += String.fromCharCode('A'.charCodeAt(0) + i);
    }
    result += ") = ";
    //Output mterms
    result += " SUM m(";
    for(var i = 0, len = ctx.mterms.length; i < len; ++i)
    {
      var term = ctx.mterms[i];
      if (i != 0) result += ", ";
      result += term.toTermString();
    }
    result += ")";
    //Output dterms
    result += " + SUM d(";
    for(var i = 0, len = ctx.dterms.length; i < len; ++i)
    {
      var term = ctx.dterms[i];
      if (i != 0) result += ", ";
      result += term.toTermString();
    }
    result += ")";
    $('.output #func').html(result);
  }

  function outputFunctionTable(ctx)
  {
    var result = "";
    var header = "";
    var body = "";
    var row = "";

    result = "<table>";
    header = "<th></th>";
    for(var i = 0, len = ctx.bits; i < len; ++i)
    {
      header += "<th>" + (String.fromCharCode('A'.charCodeAt(0) + i)) + "</th>";
    }
    header += "<th></th>"
    header += "<th>F</th>";
    result += "<tr>" + header + "</tr>";

    for(var j = 0, len = Math.pow(2, ctx.bits); j < len; ++j)
    {
      row = "<tr>";
      row += "<td>" + j + "</td>";
      for(var i = ctx.bits - 1; i >= 0; --i)
      {
        row += "<td>" + ((j >> i) % 2) + "</td>";
      }

      var flag = false;
      if (containsBitTerm(ctx.mterms, new BitTerm(formatBitTerm(ctx, j))))
      {
        row += "<td></td><td>" + "1" + "</td>";
      }
      else if (containsBitTerm(ctx.dterms, new BitTerm(formatBitTerm(ctx, j))))
      {
        row += "<td></td><td>" + "X" + "</td>";
      }
      else
      {
        row += "<td></td><td>" + "0" + "</td>";
      }
      row += "</tr>";
      body += row;
    }
    result += body;

    result += "</table>";
    $('.output #functable').html(result);
  }

  function outputOneGroups(ctx, onegroups, title)
  {
    var result = "";
    var header = "";
    var row = "";

    //Output header
    result = "<div style=\"display: inline-block; padding: 0px 10px;\">"
    result += "<h2>" + title + "</h2>";
    result += "<table>";
    header = "<th>Group</th><th>Terms</th>";
    result += "<tr>" + header + "</tr>";

    //Output group terms
    for(var i = 0, len = onegroups.size(); i < len; ++i)
    {
      var g = onegroups.getGroup(i);
      if (g.length == 0) continue;

      row += "<tr>";
      row += "<td>" + g.name + "</td>";
      for(var j = 0, len2 = g.length; j < len2; ++j)
      {
        if (j != 0) row += "<td></td>";
        var term = g[j];
        if (term.isDirty())
        {
          row += "<td bgcolor=\"" + "#D49090" +"\">"
        }
        else
        {
          row += "<td>";
        }
        row += g[j] + "</td></tr><tr>";
      }
    }
    result += row;

    result += "</table>";
    result += "</div>";

    $('.output #grouptables').append(result);
  }

  function outputOneGroupses(ctx, onegroupses)
  {
    $('.output #grouptables').empty();
    for(var i = 0, len = onegroupses.length; i < len; ++i)
    {
      var g = onegroupses[i];
      outputOneGroups(ctx, g, "Step " + (i + 1));
    }
  }

  function outputEssentials(ctx, essentials)
  {
    var result = "";
    var header = "";
    var row = "";

    //Output header
    result = "<table>";
    header = "<th>Terms</th>";
    for(var i = 0, len = ctx.mterms.length; i < len; ++i)
    {
      header += "<th>" + ctx.mterms[i].toTermString() + "</th>";
    }
    result += "<tr>" + header + "</tr>";

    //Output essentials
    for(var i = 0, len = essentials.length; i < len; ++i)
    {
      var ess = essentials[i];
      row = "<tr>";
      row += "<td>" + ess.toTermString() + "</td>";
      for(var j = 0, len2 =  ctx.mterms.length; j < len2; ++j)
      {
        var mt = ctx.mterms[j];
        if (ess.hasTerms(mt))
        {
          row += "<td>X</td>";
        }
        else
        {
          row += "<td></td>";
        }
      }
      row += "</tr>";
      result += row;
    }
    result += "</table>";

    $('.output #essentialtable').html(result);
  }

  function outputPrimeImplicantTerms(ctx, primeterms)
  {
    var result = "";
    result += "<h3>";
    for(var i = 0; i < primeterms.length; ++i)
    {
      result += "<h3>";
      var term = primeterms[i];
      if (i != 0) result += "";
      result += term.toCanonicalString();
      result += "</h3>";
    }

    $('.output #primeimplicant').html(result);
  }

  function outputSolution(ctx, solution)
  {
    $('.output #solution').text("Solution: " + solution);
  }

  function process(mterms, dterms)
  {
    var ctx = createContext(mterms, dterms);
    outputInit(ctx);

    var oneGroupses = [];
    console.log("Processing BitTerms to OneGroups . . .");
    var oneGroup = processBitTermsToOneGroups(ctx, ctx.terms);
    oneGroupses.push(oneGroup);

    console.log("Processing OneGroups to Implicants . . .");
    var impGroup = new OneGroups();
    impGroup.addGroup(oneGroup);
    var nextGroup = oneGroup;
    var i = 2;
    while(!nextGroup.isEmpty())
    {
      nextGroup = processBitTermGroups(ctx, nextGroup);
      if (nextGroup.size() > 0)
      {
        impGroup.addGroup(nextGroup);
        oneGroupses.push(nextGroup);
      }
    }
    outputOneGroupses(ctx, oneGroupses);

    console.log("Processing Implicants to Essentials . . .");
    var essterms = processImplicantsToEssentialTerms(ctx, impGroup);
    outputEssentials(ctx, essterms);

    console.log("Evaluating Essentials to Prime Essentials . . .");
    var simterms = [];
    var unsimterms = [];
    evaluateEssentialsToPrimeEssentials(ctx, essterms, simterms, unsimterms);
    outputPrimeImplicantTerms(ctx, simterms);

    console.log("Evaluating Unsimplified Terms to Simplified . . .");
    evaluateUnsimplifiedTermsToSimplified(ctx, simterms, unsimterms);

    console.log("Solution Found!");
    var output = "";
    for(var i = 0; i < simterms.length; ++i)
    {
      if (i > 0)
      {
        output += " + ";
      }

      output += "" + simterms[i].toCanonicalString();
    }
    console.log("SOLUTION: " + output);
    outputSolution(ctx, output);
  }

  function processBitTermsToOneGroups(ctx, bitterms)
  {
    var oneGroup = new OneGroups();
    for(var i = 0, len = bitterms.length; i < len; ++i)
    {
      var bitterm = bitterms[i];
      var j = onesOfBitTerm(bitterm.getBits());
      var g = oneGroup.addToGroup(j, bitterm);
      if (!g.name) g.name = "G" + j;
    }
    return oneGroup;
  }

  function processBitTermGroups(ctx, btGroup)
  {
    console.log("Process bit terms to diff eachother");
    var result = new OneGroups();

    for(var i = 0, len = btGroup.size() - 1; i < len; ++i)
    {
      var g = btGroup.getGroup(i);
      var h = btGroup.getGroup(i + 1);

      console.log("Compare " + g.name + " with " + h.name);
      for(var j = 0, len2 = g.length; j < len2; ++j)
      {
        var gi = g[j];
        for(var k = 0, len3 = h.length; k < len3; ++k)
        {
          var hi = h[k];
          var d = diffBitTerms(ctx, gi.getBits(), hi.getBits());
          if (d)
          {
            var bt = new BitTerm(d);
            bt.addTerms(gi.getTerms());
            bt.addTerms(hi.getTerms());
            gi.markDirty();
            hi.markDirty();

            console.log(" Found diff: " + gi + " and " + hi + " = " + bt);
            var newg = result.addToGroup(i, bt);
            if (!newg.name) newg.name = g.name + "-" + h.name;
          }
        }
      }
    }

    return result;
  }

  function processImplicantsToEssentialTerms(ctx, impGroup)
  {
    var result = [];
    for(var i = 0; i < impGroup.size(); ++i)
    {
      var group = impGroup.getGroup(i);

      for(var j = 0; j < group.length; ++j)
      {
        var bitterm = group[j];
        if (!bitterm.isDirty())
        {
          if (containsBitTerm(result, bitterm) == false)
          {
            result.push(bitterm);
          }
        }
      }
    }
    return result;
  }

  function evaluateEssentialsToPrimeEssentials(ctx, essterms, simterms, unsimterms)
  {
    for(var i = 0; i < ctx.mterms.length; ++i)
    {
      var primeterm = null;
      var isprime = false;
      var ct = ctx.mterms[i];

      for(var j = 0; j < essterms.length; ++j)
      {
        var et = essterms[j];

        if (et.hasTerms(ct) == true)
        {
          console.log(et + " has terms " + ct);
          if (isprime == false)
          {
            console.log("Therefore is a prime term . . .");
            primeterm = et;
            isprime = true;
          }
          else
          {
            console.log("But is NOT since found more!");
            primeterm = null;
            isprime = false;
            break;
          }
        }
        else
        {
          console.log(et + " does not have terms " + ct);
        }
      }

      if (isprime == true)
      {
        console.log("This is it! Found the prime " + primeterm);
        if (simterms.indexOf(primeterm) == -1)
        {
          console.log("ADDING " + primeterm + " AS PRIME TERM . . .");
          simterms.push(primeterm);
        }
        else
        {
          console.log(" . . . however, not adding it since it already is a prime . . .");
        }
      }
    }

    console.log("FOUND: PRIME ESS TERMS! > " + simterms);

    //EVALUATE Unsimplified Terms
    for(var i = 0; i < essterms.length; ++i)
    {
      var essterm = essterms[i];
      var terms = essterm.getTerms();
      if (simterms.indexOf(essterm) == -1)
      {
        //Check if has covered terms . . .
        var covered = false;
        for(var j = 0; j < simterms.length; ++j)
        {
          var st = simterms[j];
          essterm.removeTerms(st.getTerms());
          if (essterm.isEmpty() == true)
          {
            covered = true;
            break;
          }
        }

        if (covered == false)
        {
            unsimterms.push(essterm);
        }
        else
        {
          console.log(essterm + " is completely covered! Skipping unsimplified term . . .");
        }
      }
    }
  }

  function evaluateUnsimplifiedTermsToSimplified(ctx, simterms, unsimterms)
  {
    if (unsimterms.length > 0)
    {
      //Find a product of sums . . .
      var pos = [];
      for(var i = 0; i < ctx.mterms.length; ++i)
      {
        var sum = [];
        var mterm = ctx.mterms[i];
        for(var j = 0; j < unsimterms.length; ++j)
        {
          var term = unsimterms[j];
          if (term.hasTerms(mterm) == true)
          {
            sum.push(term);
          }
        }

        if (sum.length > 0)
        {
          pos.push(sum);
        }
      }

      console.log("FOUND: POS TERMS! > " + pos);

      //Distribute to find sum of products . . .
      var sop = POS2SOP(pos);
      console.log("Finished distribution to SOP. . .");
      console.log(SOPToString(sop));

      //SIMPLIFY
      console.log("BEGIN SIMPLIFICATION OF SOP!");
      simplify(sop);

      //GET PRODS WITH LEAST TERMS
      var least = [];
      least.push(sop[0]);
      for(var i = 1; i < sop.length; ++i)
      {
        var prod = sop[i];
        if (prod.length == least[0].length)
        {
          least.push(prod);
        }
        else if (prod.length < least[0].length)
        {
          least.length = 0;
          least.push(prod);
        }
      }
      console.log("Found Products with Least Terms:");
      console.log(least);

      //GET TERMS WITH MOST '-', THEN ADD ONE TO SIMTERMS
      var xprod = null;
      var xbits = 0;
      for(var i = 0; i < least.length; ++i)
      {
        var prod = least[i];
        var bits = 0;
        for(var j = 0; j < prod.length; ++j)
        {
          var term = prod[j];
          bits += (prod[j].getBits().match(/-/g)||[]).length;
        }

        if (xprod == null || bits < xbits)
        {
          xprod = prod;
          xbits = bits;
        }
        else if (bits == xbits)
        {
          console.log("Found other possible simplified term . . . ignoring it . . .");
        }
      }
      console.log("Found essential simplified prod:");
      console.log(xprod);
      console.log("Adding to simplified terms. . .");
      for(var i = 0; i < xprod.length; ++i)
      {
        simterms.push(xprod[i]);
      }
    }
  }

  function SOPToString(sop)
  {
    var s = "";
    for(var i = 0; i < sop.length; ++i)
    {
      if (i != 0)
      {
        s += " + ";
      }

      s += "(";
      prod = sop[i];
      for(var j = 0; j < prod.length; ++j)
      {
        var term = prod[j];
        if (j != 0)
        {
          s += "*";
        }
        s += "" + term.toCanonicalString();
      }
      s += ")";
    }
    return s;
  }

  function POSToString(pos)
  {
    var s = "";
    for(var i = 0; i < pos.length; ++i)
    {
      s += "(";
      sum = pos[i];
      for(var j = 0; j < sum.length; ++j)
      {
        var term = sum[j];
        if (j != 0)
        {
          s += " + ";
        }
        s += "" + term.toCanonicalString();
      }
      s += ")";
    }
    return s;
  }

  function POS2SOP(pos)
  {
    console.log("Converting POS to SOP . . .");
    console.log(POSToString(pos));

    var sop = [];
    var sum = pos.splice(0, 1)[0];
    for(var i = 0; i < sum.length; ++i)
    {
      var prod = [];
      prod.push(sum[i]);
      sop.push(prod);
    }
    return _POS2SOP(sop, pos);
  }

  function _POS2SOP(sop, pos)
  {
    if (pos.length == 0)
    {
      return sop;
    }
    else
    {
      console.log("SOP Solved: " + SOPToString(sop));
      console.log("POS Remaining: " + POSToString(pos));
      console.log("Multiplying . . .");
      var sum = pos.splice(0, 1)[0];
      return _POS2SOP(distribute(sop, sum), pos);
    }
  }

  function distribute(sop, sum)
  {
    var result = [];
    for(var i = 0; i < sop.length; ++i)
    {
      for(var j = 0; j < sum.length; ++j)
      {
        var prod = sop[i].slice();
        var term = sum[j];
        if (prod.indexOf(term) == -1)
        {
          prod.push(term);
        }
        result.push(prod);
      }
    }
    return result;
  }

  function simplify(sop)
  {
    console.log("UNSIMPLIFIED: " + SOPToString(sop));

    //X+X=X
    for(var i = 0; i < sop.length; ++i)
    {
      var prod = sop[i];
      for(var ii = 0; ii < sop.length; ++ii)
      {
        if (ii == i) continue;

        var other = sop[ii];
        var flag = true;
        for(var j = 0; j < prod.length; ++j)
        {
          var term = prod[j];
          if (other.indexOf(term) == -1)
          {
            flag = false;
            break;
          }
        }

        if (flag == true)
        {
          sop.splice(ii, 1);
          if (ii < i)
          {
            --i;
          }
          --ii;
        }
      }
    }
    console.log("SIMPLIFIED BY: X+X=X AND X+XY=X");
    console.log("FOUND: " + SOPToString(sop));
  }

  </script>
</head>

<body onload="init()">
  <div>
    m-terms:
    <input id="inputm" value="4,8,10,11,12,15"/>
    d-terms:
    <input id="inputd" value="9,14"/>
  </div>
  <button onclick="process(parse($('#inputm').val()), parse($('#inputd').val()))">Process</button>

  <br />

  <div class="output" style="padding: 4vh 4vw; border-style: solid; border-width: 1px">
    <div style="column-count: 2; column-span: 1; display: block; clear: both; width: 100%">
      <div>
        m: <span id="mterms">?</span>
      </div>
      <div>
        d: <span id="dterms">?</span>
      </div>
    </div>
    <br />
    <span id="func">F(?) = ?</span>
    <br />
    <br />
    <span id="functable"></span>
    <br />
    <span id="grouptable"></span>
    <br />
    <h2>Group Tables</h2>
    <span id="grouptables"></span>
    <br />
    <br />
    <h2>Implicant Table</h2>
    <span id="essentialtable"></span>
    <br />
    <h2>Prime Implicant Terms</h2>
    <span id="primeimplicant"></span>
    <h1 id="solution" style="text-align: center"></h1>
  </div>
  <subtitle>Developed by Andrew Kuo</subtitle>
</body>

</html>
